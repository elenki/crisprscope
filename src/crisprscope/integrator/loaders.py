"""
CRISPRScope: Data loading functions for the Integrator module.

This module contains functions to parse and load the various output and
configuration files generated by the CRISPRScope orchestrator and CRISPResso2.
"""

import pandas as pd
from pathlib import Path
from typing import Dict, Any

import logging
logger = logging.getLogger(__name__)

def load_settings(settings_path: Path) -> Dict[str, Any]:
    """
    Parses the settings.txt configuration file.

    This function reads a key-value formatted settings file, ignoring
    commented lines (starting with '#') and handling various whitespace.

    Args:
        settings_path: The path to the settings.txt file.

    Returns:
        A dictionary containing the parsed key-value pairs.
    """
    if not settings_path.is_file():
        logger.error(f"Settings file not found at: {settings_path}")
        raise FileNotFoundError(f"Settings file not found: {settings_path}")

    logger.info(f"Parsing settings from: {settings_path}")
    settings = {}
    with open(settings_path, 'r') as f:
        for line in f:
            line = line.strip()
            # Skip empty lines and comments
            if not line or line.startswith('#'):
                continue
            
            # Split on the first whitespace character
            parts = line.split(None, 1)
            if len(parts) == 2:
                key, value = parts
                # Store the key-value pair
                settings[key] = value
            else:
                logger.warning(f"Could not parse line in settings file: '{line}'")
    
    logger.info(f"Successfully loaded {len(settings)} parameters from settings file.")
    return settings

def load_amplicons(amplicons_path: Path) -> pd.DataFrame:
    """
    Parses the amplicons.txt file into a DataFrame.

    The amplicon file is expected to be a tab-separated file with a header.
    This function will use the first column (expected to be the amplicon name)
    as the index for the DataFrame, making lookups easy.

    Args:
        amplicions_path: The path to the amplicons.txt file.

    Returns:
        A pandas DataFrame containing amplicon information, indexed by amplicon name.
    """
    if not amplicons_path.is_file():
        logger.error(f"Amplicons file not found at: {amplicons_path}")
        raise FileNotFoundError(f"Amplicons file not found: {amplicons_path}")

    logger.info(f"Parsing amplicons from: {amplicons_path}")
    
    # Assuming the file is tab-separated with a header.
    # We will use the first column as the index.
    try:
        # The header is malformed in the example, so we name the columns explicitly.
        df = pd.read_csv(amplicons_path, sep='\t', header=None, index_col=0, names=['sequence', 'guide'])
        df.index.name = 'amplicon_name'
        logger.info(f"Successfully loaded {len(df)} amplicons.")
        return df
    except Exception as e:
        logger.error(f"Failed to parse amplicons file: {e}")
        raise

def load_editing_summary(summary_path: Path) -> pd.DataFrame:
    """
    Loads the main data matrix from settings.txt.filteredEditingSummary.txt.

    This file contains the core data: modification percentages and total read
    counts for every cell at every amplicon.

    Args:
        summary_path: The path to the filteredEditingSummary.txt file.

    Returns:
        A pandas DataFrame with cell barcodes as the index and metrics as columns.
    """
    if not summary_path.is_file():
        logger.error(f"Editing summary file not found at: {summary_path}")
        raise FileNotFoundError(f"Editing summary file not found: {summary_path}")

    logger.info(f"Parsing editing summary from: {summary_path}")
    try:
        # The first column is the cell barcode, which we use as the index.
        df = pd.read_csv(summary_path, sep='\t', index_col=0)
        df.index.name = 'cell_barcode'
        logger.info(f"Successfully loaded editing data for {df.shape[0]} cells and {df.shape[1]} metrics.")
        return df
    except Exception as e:
        logger.error(f"Failed to parse editing summary file: {e}")
        raise

def load_quality_scores(scores_path: Path) -> pd.DataFrame:
    """
    Loads the cell quality metrics from settings.txt.amplicon_score.txt.

    Args:
        scores_path: The path to the amplicon_score.txt file.

    Returns:
        A pandas DataFrame with cell barcodes as the index and quality scores.
    """
    if not scores_path.is_file():
        logger.error(f"Amplicon scores file not found at: {scores_path}")
        raise FileNotFoundError(f"Amplicon scores file not found: {scores_path}")

    logger.info(f"Parsing quality scores from: {scores_path}")
    try:
        # The first column is the cell barcode.
        df = pd.read_csv(scores_path, sep='\t', index_col=0)
        # The file uses 'Unnamed: 0' for the barcode column name, let's fix it.
        df.index.name = 'cell_barcode'
        logger.info(f"Successfully loaded quality scores for {len(df)} cells.")
        return df
    except Exception as e:
        logger.error(f"Failed to parse quality scores file: {e}")
        raise
